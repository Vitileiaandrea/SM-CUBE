<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM-CUBE Meat Packing Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .cube-canvas { width: 100%; height: 500px; }
        .status-indicator { width: 12px; height: 12px; border-radius: 50%; }
        .status-ok { background-color: #22c55e; }
        .status-warning { background-color: #eab308; }
        .status-error { background-color: #ef4444; }
        .height-cell { transition: background-color 0.3s; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .active-slice { animation: pulse 1s infinite; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-blue-400">SM-CUBE Meat Packing Simulation</h1>
            <p class="text-gray-400">Circular Conveyor + Fanuc Robot + Intelligent Layer-by-Layer Filling (95% min coverage)</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-2 space-y-6">
                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Cube 3D View</h2>
                    <div id="cube-3d" class="cube-canvas bg-gray-900 rounded"></div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Height Map</h2>
                    <div id="height-map" class="grid gap-0.5" style="grid-template-columns: repeat(42, 1fr);"></div>
                    <div class="flex justify-between mt-2 text-sm text-gray-400">
                        <span>0mm</span>
                        <span>125mm</span>
                        <span>250mm</span>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Training Progress</h2>
                    <canvas id="training-chart" height="200"></canvas>
                </div>
            </div>

            <div class="space-y-6">
                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">System Status</h2>
                    <div class="space-y-3">
                        <div class="flex items-center justify-between">
                            <span>Agent</span>
                            <div class="flex items-center gap-2">
                                <div id="agent-status" class="status-indicator status-warning"></div>
                                <span id="agent-status-text" class="text-sm">Loading...</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span>Robot</span>
                            <div class="flex items-center gap-2">
                                <div id="robot-status" class="status-indicator status-warning"></div>
                                <span id="robot-status-text" class="text-sm">Disconnected</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span>PLC</span>
                            <div class="flex items-center gap-2">
                                <div id="plc-status" class="status-indicator status-warning"></div>
                                <span id="plc-status-text" class="text-sm">Disconnected</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span>Conveyor</span>
                            <div class="flex items-center gap-2">
                                <div id="conveyor-status" class="status-indicator status-warning"></div>
                                <span id="conveyor-status-text" class="text-sm">Stopped</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Cube Metrics</h2>
                    <div class="space-y-4">
                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <span>Fill Percentage</span>
                                <span id="fill-percentage">0%</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-3">
                                <div id="fill-bar" class="bg-blue-500 h-3 rounded-full transition-all" style="width: 0%"></div>
                            </div>
                        </div>
                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <span>Layer Flatness</span>
                                <span id="flatness">100%</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-3">
                                <div id="flatness-bar" class="bg-green-500 h-3 rounded-full transition-all" style="width: 100%"></div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4 mt-4">
                            <div class="text-center p-3 bg-gray-700 rounded">
                                <div id="slices-placed" class="text-2xl font-bold text-blue-400">0</div>
                                <div class="text-sm text-gray-400">Slices Placed</div>
                            </div>
                            <div class="text-center p-3 bg-gray-700 rounded">
                                <div id="volume-filled" class="text-2xl font-bold text-green-400">0</div>
                                <div class="text-sm text-gray-400">Volume (cmÂ³)</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Current Slice</h2>
                    <div id="current-slice" class="space-y-2">
                        <div class="flex justify-between">
                            <span class="text-gray-400">Width:</span>
                            <span id="slice-width">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Length:</span>
                            <span id="slice-length">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Thickness:</span>
                            <span id="slice-thickness">-</span>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Controls</h2>
                    <div class="space-y-3">
                        <button id="btn-reset" class="w-full bg-blue-600 hover:bg-blue-700 py-2 px-4 rounded transition">
                            Reset Cube
                        </button>
                        <button id="btn-add-slice" class="w-full bg-green-600 hover:bg-green-700 py-2 px-4 rounded transition">
                            Add Random Slice
                        </button>
                        <button id="btn-auto-fill" class="w-full bg-purple-600 hover:bg-purple-700 py-2 px-4 rounded transition">
                            Auto Fill (10 slices)
                        </button>
                        <button id="btn-press-layer" class="w-full bg-yellow-600 hover:bg-yellow-700 py-2 px-4 rounded transition">
                            Press Layer
                        </button>
                        <button id="btn-emergency" class="w-full bg-red-600 hover:bg-red-700 py-2 px-4 rounded transition">
                            Emergency Stop
                        </button>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">API Connection</h2>
                    <div class="space-y-3">
                        <input id="api-url" type="text" value="http://localhost:8000" 
                               class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                        <button id="btn-connect" class="w-full bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded transition">
                            Connect
                        </button>
                        <div id="connection-status" class="text-sm text-center text-gray-400">Not connected</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let apiUrl = 'http://localhost:8000';
        let ws = null;
        let scene, camera, renderer, cube3D;
        let heightMapData = [];
        let trainingChart = null;

        function init3DScene() {
            const container = document.getElementById('cube-3d');
            const width = container.clientWidth;
            const height = 400;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(300, 300, 300);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            const cubeGeometry = new THREE.BoxGeometry(210, 250, 210);
            const cubeEdges = new THREE.EdgesGeometry(cubeGeometry);
            const cubeLine = new THREE.LineSegments(
                cubeEdges,
                new THREE.LineBasicMaterial({ color: 0x3b82f6 })
            );
            cubeLine.position.y = 125;
            scene.add(cubeLine);

            const gridHelper = new THREE.GridHelper(300, 30, 0x444444, 0x222222);
            scene.add(gridHelper);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 200, 100);
            scene.add(directionalLight);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (cube3D) {
                cube3D.rotation.y += 0.002;
            }
            renderer.render(scene, camera);
        }

        function initHeightMap() {
            const container = document.getElementById('height-map');
            container.innerHTML = '';
            for (let i = 0; i < 42; i++) {
                for (let j = 0; j < 42; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'height-cell';
                    cell.style.width = '100%';
                    cell.style.paddingBottom = '100%';
                    cell.style.backgroundColor = '#1f2937';
                    cell.dataset.x = i;
                    cell.dataset.y = j;
                    container.appendChild(cell);
                }
            }
        }

        function updateHeightMap(heightMap) {
            const cells = document.querySelectorAll('.height-cell');
            const maxHeight = 50;
            
            cells.forEach((cell, idx) => {
                const x = Math.floor(idx / 42);
                const y = idx % 42;
                if (heightMap[x] && heightMap[x][y] !== undefined) {
                    const height = heightMap[x][y];
                    const intensity = Math.min(height / maxHeight, 1);
                    const r = Math.floor(59 + intensity * 100);
                    const g = Math.floor(130 + intensity * 50);
                    const b = Math.floor(246 - intensity * 100);
                    cell.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                }
            });
        }

        function initTrainingChart() {
            const ctx = document.getElementById('training-chart').getContext('2d');
            trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Episode Reward',
                        data: [],
                        borderColor: '#3b82f6',
                        tension: 0.1,
                        fill: false
                    }, {
                        label: 'Fill %',
                        data: [],
                        borderColor: '#22c55e',
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true, grid: { color: '#374151' } },
                        x: { grid: { color: '#374151' } }
                    },
                    plugins: {
                        legend: { labels: { color: '#9ca3af' } }
                    }
                }
            });
        }

        async function fetchStatus() {
            try {
                const response = await fetch(`${apiUrl}/status`);
                const data = await response.json();
                
                updateStatusIndicator('agent', data.agent_loaded, data.agent_loaded ? 'Ready' : 'Not loaded');
                updateStatusIndicator('robot', data.robot_connected, data.robot_connected ? 'Connected' : 'Disconnected');
                updateStatusIndicator('plc', data.plc_connected, data.plc_connected ? 'Connected' : 'Disconnected');
                
                document.getElementById('fill-percentage').textContent = `${data.cube_fill_percentage.toFixed(1)}%`;
                document.getElementById('fill-bar').style.width = `${data.cube_fill_percentage}%`;
                document.getElementById('slices-placed').textContent = data.slices_placed;
                
                document.getElementById('connection-status').textContent = 'Connected';
                document.getElementById('connection-status').className = 'text-sm text-center text-green-400';
            } catch (error) {
                document.getElementById('connection-status').textContent = 'Connection failed';
                document.getElementById('connection-status').className = 'text-sm text-center text-red-400';
            }
        }

        async function fetchCubeState() {
            try {
                const response = await fetch(`${apiUrl}/cube/state`);
                const data = await response.json();
                
                updateHeightMap(data.height_map);
                
                document.getElementById('fill-percentage').textContent = `${data.fill_percentage.toFixed(1)}%`;
                document.getElementById('fill-bar').style.width = `${data.fill_percentage}%`;
                document.getElementById('flatness').textContent = `${(data.flatness * 100).toFixed(1)}%`;
                document.getElementById('flatness-bar').style.width = `${data.flatness * 100}%`;
                document.getElementById('slices-placed').textContent = data.placed_slices.length;
                document.getElementById('volume-filled').textContent = (data.total_volume_filled / 1000).toFixed(0);
                
                update3DView(data.placed_slices);
            } catch (error) {
                console.error('Failed to fetch cube state:', error);
            }
        }

        function createIrregularSliceGeometry(width, length, thickness, shapeMask) {
            const shape = new THREE.Shape();
            const irregularity = 0.15;
            const segments = 12;
            
            const hw = width / 2;
            const hl = length / 2;
            
            const points = [];
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const baseRadius = Math.sqrt(hw * hw + hl * hl) * 0.7;
                const noise = 1 + (Math.random() - 0.5) * irregularity * 2;
                const r = baseRadius * noise;
                
                let x = Math.cos(angle) * hw * noise;
                let z = Math.sin(angle) * hl * noise;
                
                x = Math.max(-hw, Math.min(hw, x));
                z = Math.max(-hl, Math.min(hl, z));
                
                points.push({ x, z });
            }
            
            shape.moveTo(points[0].x, points[0].z);
            for (let i = 1; i < points.length; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                const cpX = (prev.x + curr.x) / 2 + (Math.random() - 0.5) * 5;
                const cpZ = (prev.z + curr.z) / 2 + (Math.random() - 0.5) * 5;
                shape.quadraticCurveTo(cpX, cpZ, curr.x, curr.z);
            }
            const last = points[points.length - 1];
            const first = points[0];
            shape.quadraticCurveTo(
                (last.x + first.x) / 2,
                (last.z + first.z) / 2,
                first.x, first.z
            );
            
            const extrudeSettings = {
                steps: 1,
                depth: thickness,
                bevelEnabled: true,
                bevelThickness: thickness * 0.1,
                bevelSize: 2,
                bevelSegments: 2
            };
            
            return new THREE.ExtrudeGeometry(shape, extrudeSettings);
        }

        function update3DView(placedSlices) {
            if (cube3D) {
                scene.remove(cube3D);
            }
            
            cube3D = new THREE.Group();
            
            placedSlices.forEach((slice, idx) => {
                const geometry = createIrregularSliceGeometry(
                    slice.width * 0.9,
                    slice.length * 0.9,
                    slice.thickness
                );
                
                const hue = (idx * 37 + 10) % 360;
                const saturation = 60 + Math.random() * 20;
                const lightness = 45 + Math.random() * 15;
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(`hsl(${hue}, ${saturation}%, ${lightness}%)`),
                    transparent: true,
                    opacity: 0.85,
                    flatShading: false,
                    shininess: 30
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.rotation.x = -Math.PI / 2;
                
                mesh.position.set(
                    slice.x - 105 + slice.width / 2,
                    slice.z,
                    slice.y - 105 + slice.length / 2
                );
                
                const tiltX = (Math.random() - 0.5) * 0.05;
                const tiltZ = (Math.random() - 0.5) * 0.05;
                mesh.rotation.y = tiltX;
                mesh.rotation.z = tiltZ;
                
                cube3D.add(mesh);
            });
            
            scene.add(cube3D);
        }

        function updateStatusIndicator(id, isOk, text) {
            const indicator = document.getElementById(`${id}-status`);
            const textEl = document.getElementById(`${id}-status-text`);
            
            indicator.className = `status-indicator ${isOk ? 'status-ok' : 'status-warning'}`;
            textEl.textContent = text;
        }

        async function resetCube() {
            try {
                await fetch(`${apiUrl}/cube/reset`, { method: 'POST' });
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to reset cube:', error);
            }
        }

        async function addRandomSlice() {
            try {
                const response = await fetch(`${apiUrl}/cube/auto_fill?num_slices=1`, {
                    method: 'POST'
                });
                const result = await response.json();
                console.log('Placement result:', result);
                
                if (result.placements && result.placements.length > 0) {
                    const p = result.placements[0];
                    document.getElementById('slice-width').textContent = `${p.width.toFixed(0)}mm`;
                    document.getElementById('slice-length').textContent = `${p.length.toFixed(0)}mm`;
                    document.getElementById('slice-thickness').textContent = `${((p.thickness_min + p.thickness_max) / 2).toFixed(0)}mm`;
                }
                
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to add slice:', error);
            }
        }

        async function autoFill(count = 10) {
            try {
                const response = await fetch(`${apiUrl}/cube/auto_fill?num_slices=${count}`, {
                    method: 'POST'
                });
                const result = await response.json();
                console.log('Auto fill result:', result);
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to auto fill:', error);
            }
        }

        async function pressLayer() {
            try {
                const response = await fetch(`${apiUrl}/cube/press_layer?compression_ratio=0.9`, {
                    method: 'POST'
                });
                const result = await response.json();
                console.log('Press layer result:', result);
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to press layer:', error);
            }
        }

        async function emergencyStop() {
            try {
                await fetch(`${apiUrl}/robot/emergency_stop`, { method: 'POST' });
                updateStatusIndicator('robot', false, 'EMERGENCY STOP');
                updateStatusIndicator('conveyor', false, 'STOPPED');
            } catch (error) {
                console.error('Failed to trigger emergency stop:', error);
            }
        }

        function connectWebSocket() {
            const wsUrl = apiUrl.replace('http', 'ws') + '/ws';
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('WebSocket connected');
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'state_update') {
                    updateHeightMap(data.height_map);
                    document.getElementById('fill-percentage').textContent = `${data.fill_percentage.toFixed(1)}%`;
                    document.getElementById('fill-bar').style.width = `${data.fill_percentage}%`;
                    document.getElementById('flatness').textContent = `${(data.flatness * 100).toFixed(1)}%`;
                    document.getElementById('flatness-bar').style.width = `${data.flatness * 100}%`;
                    document.getElementById('slices-placed').textContent = data.slices_placed;
                }
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                setTimeout(connectWebSocket, 5000);
            };
        }

        document.getElementById('btn-reset').addEventListener('click', resetCube);
        document.getElementById('btn-add-slice').addEventListener('click', addRandomSlice);
        document.getElementById('btn-auto-fill').addEventListener('click', () => autoFill(10));
        document.getElementById('btn-press-layer').addEventListener('click', pressLayer);
        document.getElementById('btn-emergency').addEventListener('click', emergencyStop);
        document.getElementById('btn-connect').addEventListener('click', () => {
            apiUrl = document.getElementById('api-url').value;
            fetchStatus();
            fetchCubeState();
            connectWebSocket();
        });

        window.addEventListener('load', () => {
            init3DScene();
            initHeightMap();
            initTrainingChart();
            fetchStatus();
            fetchCubeState();
            
            setInterval(fetchStatus, 5000);
            setInterval(fetchCubeState, 2000);
        });
    </script>
</body>
</html>
