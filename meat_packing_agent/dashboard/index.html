<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SM-CUBE Simulazione Riempimento Cubi</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .cube-canvas { width: 100%; height: 500px; }
        .status-indicator { width: 12px; height: 12px; border-radius: 50%; }
        .status-ok { background-color: #22c55e; }
        .status-warning { background-color: #eab308; }
        .status-error { background-color: #ef4444; }
        .height-cell { transition: background-color 0.3s; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .active-slice { animation: pulse 1s infinite; }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div class="container mx-auto px-4 py-6">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-blue-400">SM-CUBE Simulazione Riempimento Cubi</h1>
            <p class="text-gray-400">Nastro Circolare + Robot Fanuc + Riempimento Intelligente Strato per Strato (min 95% copertura)</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-2 space-y-6">
                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Vista 3D Cubo</h2>
                    <div id="cube-3d" class="cube-canvas bg-gray-900 rounded"></div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Mappa Altezze</h2>
                    <div id="height-map" class="grid gap-0.5" style="grid-template-columns: repeat(42, 1fr);"></div>
                    <div class="flex justify-between mt-2 text-sm text-gray-400">
                        <span>0mm</span>
                        <span>125mm</span>
                        <span>250mm</span>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Progresso Addestramento</h2>
                    <canvas id="training-chart" height="200"></canvas>
                </div>
            </div>

            <div class="space-y-6">
                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Stato Sistema</h2>
                    <div class="space-y-3">
                        <div class="flex items-center justify-between">
                            <span>Agente</span>
                            <div class="flex items-center gap-2">
                                <div id="agent-status" class="status-indicator status-warning"></div>
                                <span id="agent-status-text" class="text-sm">Caricamento...</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span>Robot</span>
                            <div class="flex items-center gap-2">
                                <div id="robot-status" class="status-indicator status-warning"></div>
                                <span id="robot-status-text" class="text-sm">Disconnesso</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span>PLC</span>
                            <div class="flex items-center gap-2">
                                <div id="plc-status" class="status-indicator status-warning"></div>
                                <span id="plc-status-text" class="text-sm">Disconnesso</span>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span>Nastro</span>
                            <div class="flex items-center gap-2">
                                <div id="conveyor-status" class="status-indicator status-warning"></div>
                                <span id="conveyor-status-text" class="text-sm">Fermo</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Metriche Cubo</h2>
                    <div class="space-y-4">
                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <span>Percentuale Riempimento</span>
                                <span id="fill-percentage">0%</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-3">
                                <div id="fill-bar" class="bg-blue-500 h-3 rounded-full transition-all" style="width: 0%"></div>
                            </div>
                        </div>
                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <span>Planarità Strato</span>
                                <span id="flatness">100%</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-3">
                                <div id="flatness-bar" class="bg-green-500 h-3 rounded-full transition-all" style="width: 100%"></div>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4 mt-4">
                            <div class="text-center p-3 bg-gray-700 rounded">
                                <div id="slices-placed" class="text-2xl font-bold text-blue-400">0</div>
                                <div class="text-sm text-gray-400">Fettine Posizionate</div>
                            </div>
                            <div class="text-center p-3 bg-gray-700 rounded">
                                <div id="volume-filled" class="text-2xl font-bold text-green-400">0</div>
                                <div class="text-sm text-gray-400">Volume (cm³)</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Fettina Corrente</h2>
                    <div id="current-slice" class="space-y-2">
                        <div class="flex justify-between">
                            <span class="text-gray-400">Larghezza:</span>
                            <span id="slice-width">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Lunghezza:</span>
                            <span id="slice-length">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Spessore:</span>
                            <span id="slice-thickness">-</span>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Controlli</h2>
                    <div class="space-y-3">
                        <button id="btn-reset" class="w-full bg-blue-600 hover:bg-blue-700 py-2 px-4 rounded transition">
                            Svuota Cubo
                        </button>
                        <button id="btn-add-slice" class="w-full bg-green-600 hover:bg-green-700 py-2 px-4 rounded transition">
                            Aggiungi Fettina
                        </button>
                        <button id="btn-auto-fill" class="w-full bg-purple-600 hover:bg-purple-700 py-2 px-4 rounded transition">
                            Riempimento Auto (10 fettine)
                        </button>
                        <button id="btn-press-layer" class="w-full bg-yellow-600 hover:bg-yellow-700 py-2 px-4 rounded transition">
                            Pressa Strato
                        </button>
                        <button id="btn-emergency" class="w-full bg-red-600 hover:bg-red-700 py-2 px-4 rounded transition">
                            Arresto Emergenza
                        </button>
                    </div>
                </div>

                <div class="bg-gray-800 rounded-lg p-6">
                    <h2 class="text-xl font-semibold mb-4">Connessione API</h2>
                    <div class="space-y-3">
                        <input id="api-url" type="text" value="http://localhost:8000" 
                               class="w-full bg-gray-700 border border-gray-600 rounded px-3 py-2 text-sm">
                        <button id="btn-connect" class="w-full bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded transition">
                            Connetti
                        </button>
                        <div id="connection-status" class="text-sm text-center text-gray-400">Non connesso</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let apiUrl = window.location.origin;
        let ws = null;
        let scene, camera, renderer, cube3D;
        let heightMapData = [];
        let trainingChart = null;

        function init3DScene() {
            const container = document.getElementById('cube-3d');
            const width = container.clientWidth;
            const height = 400;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(300, 300, 300);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            const cubeGeometry = new THREE.BoxGeometry(210, 250, 210);
            const cubeEdges = new THREE.EdgesGeometry(cubeGeometry);
            const cubeLine = new THREE.LineSegments(
                cubeEdges,
                new THREE.LineBasicMaterial({ color: 0x3b82f6 })
            );
            cubeLine.position.y = 125;
            scene.add(cubeLine);

            const gridHelper = new THREE.GridHelper(300, 30, 0x444444, 0x222222);
            scene.add(gridHelper);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 200, 100);
            scene.add(directionalLight);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function initHeightMap() {
            const container = document.getElementById('height-map');
            container.innerHTML = '';
            for (let i = 0; i < 42; i++) {
                for (let j = 0; j < 42; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'height-cell';
                    cell.style.width = '100%';
                    cell.style.paddingBottom = '100%';
                    cell.style.backgroundColor = '#1f2937';
                    cell.dataset.x = i;
                    cell.dataset.y = j;
                    container.appendChild(cell);
                }
            }
        }

        function updateHeightMap(heightMap) {
            const cells = document.querySelectorAll('.height-cell');
            const maxHeight = 50;
            
            cells.forEach((cell, idx) => {
                const x = Math.floor(idx / 42);
                const y = idx % 42;
                if (heightMap[x] && heightMap[x][y] !== undefined) {
                    const height = heightMap[x][y];
                    const intensity = Math.min(height / maxHeight, 1);
                    const r = Math.floor(59 + intensity * 100);
                    const g = Math.floor(130 + intensity * 50);
                    const b = Math.floor(246 - intensity * 100);
                    cell.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                }
            });
        }

        function initTrainingChart() {
            const ctx = document.getElementById('training-chart').getContext('2d');
            trainingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Episode Reward',
                        data: [],
                        borderColor: '#3b82f6',
                        tension: 0.1,
                        fill: false
                    }, {
                        label: 'Fill %',
                        data: [],
                        borderColor: '#22c55e',
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true, grid: { color: '#374151' } },
                        x: { grid: { color: '#374151' } }
                    },
                    plugins: {
                        legend: { labels: { color: '#9ca3af' } }
                    }
                }
            });
        }

        async function fetchStatus() {
            try {
                const response = await fetch(`${apiUrl}/status`);
                const data = await response.json();
                
                updateStatusIndicator('agent', data.agent_loaded, data.agent_loaded ? 'Ready' : 'Not loaded');
                updateStatusIndicator('robot', data.robot_connected, data.robot_connected ? 'Connected' : 'Disconnected');
                updateStatusIndicator('plc', data.plc_connected, data.plc_connected ? 'Connected' : 'Disconnected');
                
                document.getElementById('fill-percentage').textContent = `${data.cube_fill_percentage.toFixed(1)}%`;
                document.getElementById('fill-bar').style.width = `${data.cube_fill_percentage}%`;
                document.getElementById('slices-placed').textContent = data.slices_placed;
                
                document.getElementById('connection-status').textContent = 'Connected';
                document.getElementById('connection-status').className = 'text-sm text-center text-green-400';
            } catch (error) {
                document.getElementById('connection-status').textContent = 'Connection failed';
                document.getElementById('connection-status').className = 'text-sm text-center text-red-400';
            }
        }

        async function fetchCubeState() {
            try {
                const response = await fetch(`${apiUrl}/cube/state`);
                const data = await response.json();
                
                updateHeightMap(data.height_map);
                
                document.getElementById('fill-percentage').textContent = `${data.fill_percentage.toFixed(1)}%`;
                document.getElementById('fill-bar').style.width = `${data.fill_percentage}%`;
                document.getElementById('flatness').textContent = `${(data.flatness * 100).toFixed(1)}%`;
                document.getElementById('flatness-bar').style.width = `${data.flatness * 100}%`;
                document.getElementById('slices-placed').textContent = data.placed_slices.length;
                document.getElementById('volume-filled').textContent = (data.total_volume_filled / 1000).toFixed(0);
                
                update3DView(data.placed_slices);
            } catch (error) {
                console.error('Failed to fetch cube state:', error);
            }
        }

        function seededRandom(seed) {
            const x = Math.sin(seed * 12.9898) * 43758.5453;
            return x - Math.floor(x);
        }

        function createIrregularSliceGeometry(width, length, thickness, sliceIndex, cornerInfo, sliceData) {
            const shape = new THREE.Shape();
            const irregularity = 0.15;
            
            const hw = width / 2;
            const hl = length / 2;
            
            const fillCorner = cornerInfo && cornerInfo.isCorner;
            const cornerDir = cornerInfo ? cornerInfo.direction : 'none';
            
            if (fillCorner) {
                const inset = 3;
                
                if (cornerDir === 'left_front') {
                    shape.moveTo(-hw, -hl);
                    shape.lineTo(-hw, hl - inset);
                    shape.quadraticCurveTo(-hw + inset, hl, -hw + inset * 2, hl);
                    shape.lineTo(hw - inset, hl);
                    shape.quadraticCurveTo(hw, hl - inset, hw, hl - inset * 2);
                    shape.lineTo(hw, -hl + inset * 2);
                    shape.quadraticCurveTo(hw - inset, -hl, hw - inset * 2, -hl);
                    shape.lineTo(-hw, -hl);
                } else if (cornerDir === 'right_front') {
                    shape.moveTo(hw, -hl);
                    shape.lineTo(hw, hl - inset);
                    shape.quadraticCurveTo(hw - inset, hl, hw - inset * 2, hl);
                    shape.lineTo(-hw + inset, hl);
                    shape.quadraticCurveTo(-hw, hl - inset, -hw, hl - inset * 2);
                    shape.lineTo(-hw, -hl + inset * 2);
                    shape.quadraticCurveTo(-hw + inset, -hl, -hw + inset * 2, -hl);
                    shape.lineTo(hw, -hl);
                } else if (cornerDir === 'left_back') {
                    shape.moveTo(-hw, hl);
                    shape.lineTo(-hw, -hl + inset);
                    shape.quadraticCurveTo(-hw + inset, -hl, -hw + inset * 2, -hl);
                    shape.lineTo(hw - inset, -hl);
                    shape.quadraticCurveTo(hw, -hl + inset, hw, -hl + inset * 2);
                    shape.lineTo(hw, hl - inset * 2);
                    shape.quadraticCurveTo(hw - inset, hl, hw - inset * 2, hl);
                    shape.lineTo(-hw, hl);
                } else if (cornerDir === 'right_back') {
                    shape.moveTo(hw, hl);
                    shape.lineTo(hw, -hl + inset);
                    shape.quadraticCurveTo(hw - inset, -hl, hw - inset * 2, -hl);
                    shape.lineTo(-hw + inset, -hl);
                    shape.quadraticCurveTo(-hw, -hl + inset, -hw, -hl + inset * 2);
                    shape.lineTo(-hw, hl - inset * 2);
                    shape.quadraticCurveTo(-hw + inset, hl, -hw + inset * 2, hl);
                    shape.lineTo(hw, hl);
                } else {
                    shape.moveTo(-hw, -hl);
                    shape.lineTo(-hw, hl);
                    shape.lineTo(hw, hl);
                    shape.lineTo(hw, -hl);
                    shape.lineTo(-hw, -hl);
                }
            } else {
                const segments = 12;
                const points = [];
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const noise = 1 + (seededRandom(sliceIndex * 100 + i) - 0.5) * irregularity * 2;
                    
                    let x = Math.cos(angle) * hw * noise;
                    let z = Math.sin(angle) * hl * noise;
                    
                    x = Math.max(-hw, Math.min(hw, x));
                    z = Math.max(-hl, Math.min(hl, z));
                    
                    points.push({ x, z });
                }
                
                shape.moveTo(points[0].x, points[0].z);
                for (let i = 1; i < points.length; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const cpX = (prev.x + curr.x) / 2 + (seededRandom(sliceIndex * 100 + 50 + i) - 0.5) * 5;
                    const cpZ = (prev.z + curr.z) / 2 + (seededRandom(sliceIndex * 100 + 70 + i) - 0.5) * 5;
                    shape.quadraticCurveTo(cpX, cpZ, curr.x, curr.z);
                }
                const last = points[points.length - 1];
                const first = points[0];
                shape.quadraticCurveTo(
                    (last.x + first.x) / 2,
                    (last.z + first.z) / 2,
                    first.x, first.z
                );
            }
            
            const extrudeSettings = {
                steps: 4,
                depth: thickness,
                bevelEnabled: true,
                bevelThickness: thickness * 0.15,
                bevelSize: 3,
                bevelSegments: 3
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            const sagAmount = thickness * 0.12;
            const positions = geometry.attributes.position;
            const vertex = new THREE.Vector3();
            
            for (let i = 0; i < positions.count; i++) {
                vertex.fromBufferAttribute(positions, i);
                
                const distFromCenter = Math.sqrt(vertex.x * vertex.x + vertex.y * vertex.y);
                const maxDist = Math.sqrt(hw * hw + hl * hl);
                const normalizedDist = distFromCenter / maxDist;
                
                const sagFactor = (1 - normalizedDist * normalizedDist) * sagAmount;
                
                if (vertex.z > thickness * 0.3 && vertex.z < thickness * 0.9) {
                    vertex.z -= sagFactor * (1 - Math.abs(vertex.z - thickness * 0.5) / (thickness * 0.5));
                }
                
                if (fillCorner && cornerDir !== 'none') {
                    let compressionX = 0;
                    let compressionY = 0;
                    const compressionAmount = 2;
                    
                    if (cornerDir.includes('left') && vertex.x < -hw * 0.5) {
                        compressionX = compressionAmount * (1 + vertex.x / hw);
                    }
                    if (cornerDir.includes('right') && vertex.x > hw * 0.5) {
                        compressionX = -compressionAmount * (1 - vertex.x / hw);
                    }
                    if (cornerDir.includes('front') && vertex.y < -hl * 0.5) {
                        compressionY = compressionAmount * (1 + vertex.y / hl);
                    }
                    if (cornerDir.includes('back') && vertex.y > hl * 0.5) {
                        compressionY = -compressionAmount * (1 - vertex.y / hl);
                    }
                    
                    vertex.x += compressionX;
                    vertex.y += compressionY;
                }
                
                positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function update3DView(placedSlices) {
            if (cube3D) {
                scene.remove(cube3D);
            }
            
            cube3D = new THREE.Group();
            
            placedSlices.forEach((slice, idx) => {
                const cornerDirections = ['left_front', 'left_back', 'right_front', 'right_back'];
                const edgeDirections = ['left', 'right', 'front', 'back'];
                const isCornerSlice = slice.push_direction && cornerDirections.includes(slice.push_direction);
                const isEdgeSlice = slice.push_direction && edgeDirections.includes(slice.push_direction);
                const cornerInfo = {
                    isCorner: isCornerSlice,
                    direction: slice.push_direction || 'none'
                };
                
                const geometry = createIrregularSliceGeometry(
                    slice.width * 0.9,
                    slice.length * 0.9,
                    slice.thickness,
                    idx,
                    cornerInfo,
                    slice
                );
                
                const hue = ((idx * 37 + 10) % 360) / 360;
                const saturation = 0.6 + seededRandom(idx * 3) * 0.2;
                const lightness = 0.45 + seededRandom(idx * 3 + 1) * 0.15;
                const color = new THREE.Color();
                color.setHSL(hue, saturation, lightness);
                const material = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.9,
                    flatShading: false,
                    shininess: 20
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.rotation.x = -Math.PI / 2;
                
                mesh.position.set(
                    slice.x - 105 + slice.width / 2,
                    slice.z,
                    slice.y - 105 + slice.length / 2
                );
                
                mesh.rotation.y = slice.rotation || 0;
                
                const tiltAmount = 0.03;
                let tiltX = 0;
                let tiltZ = 0;
                
                if (slice.push_direction) {
                    if (slice.push_direction.includes('left')) {
                        tiltZ = tiltAmount;
                    } else if (slice.push_direction.includes('right')) {
                        tiltZ = -tiltAmount;
                    }
                    if (slice.push_direction.includes('front')) {
                        tiltX = -tiltAmount;
                    } else if (slice.push_direction.includes('back')) {
                        tiltX = tiltAmount;
                    }
                }
                
                const baseTiltX = (seededRandom(idx * 7) - 0.5) * 0.02;
                const baseTiltZ = (seededRandom(idx * 7 + 1) - 0.5) * 0.02;
                
                mesh.rotation.x += tiltX + baseTiltX;
                mesh.rotation.z = tiltZ + baseTiltZ;
                
                cube3D.add(mesh);
            });
            
            scene.add(cube3D);
        }

        function updateStatusIndicator(id, isOk, text) {
            const indicator = document.getElementById(`${id}-status`);
            const textEl = document.getElementById(`${id}-status-text`);
            
            indicator.className = `status-indicator ${isOk ? 'status-ok' : 'status-warning'}`;
            textEl.textContent = text;
        }

        async function resetCube() {
            try {
                await fetch(`${apiUrl}/cube/reset`, { method: 'POST' });
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to reset cube:', error);
            }
        }

        async function addRandomSlice() {
            try {
                const response = await fetch(`${apiUrl}/cube/auto_fill?num_slices=1`, {
                    method: 'POST'
                });
                const result = await response.json();
                console.log('Placement result:', result);
                
                if (result.placements && result.placements.length > 0) {
                    const p = result.placements[0];
                    document.getElementById('slice-width').textContent = `${p.width.toFixed(0)}mm`;
                    document.getElementById('slice-length').textContent = `${p.length.toFixed(0)}mm`;
                    document.getElementById('slice-thickness').textContent = `${((p.thickness_min + p.thickness_max) / 2).toFixed(0)}mm`;
                }
                
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to add slice:', error);
            }
        }

        async function autoFill(count = 10) {
            try {
                const response = await fetch(`${apiUrl}/cube/auto_fill?num_slices=${count}`, {
                    method: 'POST'
                });
                const result = await response.json();
                console.log('Auto fill result:', result);
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to auto fill:', error);
            }
        }

        async function pressLayer() {
            try {
                const response = await fetch(`${apiUrl}/cube/press_layer?compression_ratio=0.9`, {
                    method: 'POST'
                });
                const result = await response.json();
                console.log('Press layer result:', result);
                await fetchCubeState();
            } catch (error) {
                console.error('Failed to press layer:', error);
            }
        }

        async function emergencyStop() {
            try {
                await fetch(`${apiUrl}/robot/emergency_stop`, { method: 'POST' });
                updateStatusIndicator('robot', false, 'EMERGENCY STOP');
                updateStatusIndicator('conveyor', false, 'STOPPED');
            } catch (error) {
                console.error('Failed to trigger emergency stop:', error);
            }
        }

        function connectWebSocket() {
            const wsUrl = apiUrl.replace('http', 'ws') + '/ws';
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('WebSocket connected');
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'state_update') {
                    updateHeightMap(data.height_map);
                    document.getElementById('fill-percentage').textContent = `${data.fill_percentage.toFixed(1)}%`;
                    document.getElementById('fill-bar').style.width = `${data.fill_percentage}%`;
                    document.getElementById('flatness').textContent = `${(data.flatness * 100).toFixed(1)}%`;
                    document.getElementById('flatness-bar').style.width = `${data.flatness * 100}%`;
                    document.getElementById('slices-placed').textContent = data.slices_placed;
                }
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected');
                setTimeout(connectWebSocket, 5000);
            };
        }

        document.getElementById('btn-reset').addEventListener('click', resetCube);
        document.getElementById('btn-add-slice').addEventListener('click', addRandomSlice);
        document.getElementById('btn-auto-fill').addEventListener('click', () => autoFill(10));
        document.getElementById('btn-press-layer').addEventListener('click', pressLayer);
        document.getElementById('btn-emergency').addEventListener('click', emergencyStop);
        document.getElementById('btn-connect').addEventListener('click', () => {
            apiUrl = document.getElementById('api-url').value;
            fetchStatus();
            fetchCubeState();
            connectWebSocket();
        });

        window.addEventListener('load', () => {
            document.getElementById('api-url').value = apiUrl;
            init3DScene();
            initHeightMap();
            initTrainingChart();
            fetchStatus();
            fetchCubeState();
            connectWebSocket();
            
            setInterval(fetchStatus, 5000);
            setInterval(fetchCubeState, 2000);
        });
    </script>
</body>
</html>
